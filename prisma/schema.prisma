// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- User & Auth Models (Unchanged) ---

model UserRoles {
  id        Int      @id
  role_name String
  users     UserHasRoles[]
  refreshTokens RefreshTokens[]
}

model User {
  id                  Int      @id @default(autoincrement())
  firstname           String
  lastname            String?
  email               String   @unique // Added @unique for data integrity
  phone_number        String   @unique // Added @unique for data integrity
  password            String
  email_verified_at   DateTime?
  phone_verified_at   DateTime?
  created_at          DateTime @default(now())

  roles                UserHasRoles[]
  address              UserAddresses[]
  otps                 UserOTP[]
  refreshTokens        RefreshTokens[]
  managedBranches      RestaurantBranches[] @relation("BranchManager")
  managedBrands        RestaurantBrands[]   @relation("BrandManager")
  onboarding_manager   OnboardingSession[]
  bankAccount UserBankAccount?
}

model RefreshTokens {
  id            Int      @id @default(autoincrement())
  user_id       Int
  refresh_token String   @unique // Should be unique
  role_id       Int
  device_info   String
  ip_address    String
  is_valid      Boolean  @default(true)
  created_at    DateTime @default(now())
  expires_at    DateTime

  user User      @relation(fields: [user_id], references: [id])
  role UserRoles @relation(fields: [role_id], references: [id])
}

model UserHasRoles {
  user_id Int
  role_id Int
  user    User      @relation(fields: [user_id], references: [id])
  role    UserRoles @relation(fields: [role_id], references: [id])

  @@id([user_id, role_id])
}

model UserOTP {
  id           Int        @id @default(autoincrement())
  user_id      Int?
  otp_code     String
  status       otp_status @default(pending)
  created_at   DateTime   @default(now())
  expires_at   DateTime
  phone_number String

  user User? @relation(fields: [user_id], references: [id])
}

enum otp_status {
  pending
  verified
  expired
}

// --- Address Models (Unchanged) ---

model Address {
  id             Int      @id @default(autoincrement())
  street_address String
  pincode        String
  city_id        Int
  latitude       Decimal? @db.Decimal(10, 8)
  longitude      Decimal? @db.Decimal(11, 8)

  users    UserAddresses[]
  location RestaurantBranches? // A branch has one location
}

model UserAddresses {
  user_id    Int
  address_id Int
  label      String

  user    User    @relation(fields: [user_id], references: [id])
  address Address @relation(fields: [address_id], references: [id])

  @@id([user_id, address_id])
}

// --- NEW, SIMPLIFIED RESTAURANT & MENU MODELS ---

// The Brand is now a simple identity container.
model RestaurantBrands {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  logo_url    String?  // Changed to optional
  description String?
  status RestaurantStatus @default(draft)
  manager_id  Int
  manager     User     @relation("BrandManager", fields: [manager_id], references: [id])
  
  branches RestaurantBranches[]
}

// The Branch is the complete, autonomous operational unit.
model RestaurantBranches {
  id                    Int      @id @default(autoincrement())
  brand_id              Int
  user_id               Int      // This is the Branch Manager's ID
  address_id            Int      @unique
  branch_name           String?
  is_accepting_orders   Boolean  @default(true)
  order_devices         devices  @default(WebDashboard)
  menu_image_url        String?
  status                RestaurantStatus @default(draft)

  brand    RestaurantBrands @relation(fields: [brand_id], references: [id])
  user     User            @relation("BranchManager", fields: [user_id], references: [id])
  location Address         @relation(fields: [address_id], references: [id])

  media             RestaurantMedia[]
  timings           RestaurantTimings[]
  menu_categories   BranchMenuCategories[] // Corrected relation name
  cuisines          BranchCuisines[]
  branch            UserBankAccount[]
  // NEW: A branch can have one onboarding session associated with it.
  onboardingSession OnboardingSession?
}

enum RestaurantStatus {
  draft
  active
  inactive
  suspended
}

enum devices {
  App
  WebDashboard
}

// The OnboardingSession is now directly linked to the Branch being created.
model OnboardingSession {
  id         Int      @id @default(autoincrement())
  status     OnboardingStatus @default(STARTED)
  manager_id Int
  branch_id  Int?     @unique // NEW: Linked to the branch being created

  onboarding_manager User              @relation(fields: [manager_id], references: [id])
  branch_onboarding  RestaurantBranches? @relation(fields: [branch_id], references: [id])
}

enum OnboardingStatus {
  STARTED
  PHASE_1_COMPLETE 
  PHASE_2_COMPLETE
  PHASE_3_COMPLETE
  COMPLETE
  DABANDONED
}

model RestaurantMedia {
  id         Int    @id @default(autoincrement())
  branch_id  Int
  media_url  String
  media_type type   @default(image)

  branch RestaurantBranches @relation(fields: [branch_id], references: [id])
}

enum type {
  image
  video
}

model RestaurantTimings {
  id         Int      @id @default(autoincrement())
  branch_id  Int
  weekDay    week_day
  start_time DateTime
  end_time   DateTime

  branch_timing RestaurantBranches @relation(fields: [branch_id], references: [id])
}

enum week_day {
  Monday 
  Tuesday 
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}

model Cuisines {
  id   Int    @id @default(autoincrement())
  name String @unique

  branches BranchCuisines[]
}

// NEW: Join table to link Cuisines directly to a Branch.
model BranchCuisines {
  branch_id   Int
  cuisine_id  Int

  branch    RestaurantBranches @relation(fields: [branch_id], references: [id])
  cuisine   Cuisines         @relation(fields: [cuisine_id], references: [id])

  @@id([branch_id, cuisine_id])
}

// The entire menu system is now branch-centric.
model BranchMenuCategories {
    id Int @id @default(autoincrement())
    branch_id Int
    name String

    branch RestaurantBranches @relation(fields: [branch_id], references: [id])
    menu_items BranchMenuItems[]
}

model BranchMenuItems {
  id          Int      @id @default(autoincrement())
  category_id Int      // NEW: Linked to a branch category
  name        String
  description String?
  price       Decimal
  image_url   String?
  is_available Boolean  @default(true)

  category  BranchMenuCategories @relation(fields: [category_id], references: [id])
  variants  BranchItemVariants[]
}

model BranchItemVariants {
  id             Int     @id @default(autoincrement())
  branch_item_id Int
  name           String
  price          Decimal

  branch_item BranchMenuItems @relation(fields: [branch_item_id], references: [id])
}

model UserBankAccount {
  id Int @id @default(autoincrement())
  user_id Int @unique
  account_number String 
  ifsc_code String
  account_type String //e.g "Savings, Current".
  branch_id      Int      @unique

  branch         RestaurantBranches @relation(fields: [branch_id], references: [id])
  bankAccount User @relation(fields: [user_id],references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

